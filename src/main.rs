mod string_test;
mod fn_demo;
mod generic_demo;
mod trait_demo;
mod pattern_destructure_demo;
mod copy_demo;
mod borrow_demo;

// 用 mod 来声明要加载的其他代码文件，如果模块内容较多，可以放在一个目录下，在该目录下放一个 mod.rs 引入该模块的其他文件。
// 这样处理后，就可以用 mod + 目录名引入这个模块了。


fn main() {
    let result = if 1 == 1 {
        "hello";
    } else {
        "world";
    };

    println!("{:?}", result);

}

// 类型是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息。
// 如 u32 类型，它是一个无符号 32 位整数，长度是 4 个字节，对齐也是 4 个字节，
// 取值在 0 ~ 4G 之间；u32 类型实现了 加减乘除、大小比较等接口，所以可以做类似
// 1 + 2、i <= 3 这样的操作。

// 类型系统其实就是，对类型进行定义、检查和处理的系统。
// 强类型和弱类型：定义后的类型是否可以隐式转换。
// Rust、Java、Swift 是显式静态语言
// Haskell 是隐式静态语言。

// 为了做到严格的类型安全，Rust 中除了 let/fn/static/const 这些定义性的语句外，都是表达式，
// 而一切表达式都有类型，所以可以说，在Rust中，类型无处不在。


// 单元测试通常编写在包含被测试代码的同一模块中。
// 当这些测试的数量增加时，它们被组织成嵌套模块形式的一个实体。
// 通常在一当前模块中创建一个子模块，对该测试进行一个命名，如
// tests, 并添加相应的注释属性（#[cfg(test)]）,
// 然后将所有与测试相关的函数放入其中。
// 该属性只是告知编译器在测试模块中引用代码，但在执行 
// cargo test 命令时生效。

// 测试原语
// Rust 内置的测试框架基于一系列主要属性和宏组成的基元。
// Rust 代码中的属性主要指元素的注释

// 断言宏 
// assert! 最简单的断言宏 